{"ast":null,"code":"import { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nexport class Subscriber extends Subscription {\n  constructor(destination) {\n    super();\n    this.isStopped = false;\n    if (destination) {\n      this.destination = destination;\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n  static create(next, error, complete) {\n    return new SafeSubscriber(next, error, complete);\n  }\n  next(value) {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value);\n    }\n  }\n  error(err) {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n  complete() {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n  unsubscribe() {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null;\n    }\n  }\n  _next(value) {\n    this.destination.next(value);\n  }\n  _error(err) {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n  _complete() {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\nexport class SafeSubscriber extends Subscriber {\n  constructor(observerOrNext, error, complete) {\n    super();\n    let next;\n    if (isFunction(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      ({\n        next,\n        error,\n        complete\n      } = observerOrNext);\n      let context;\n      if (this && config.useDeprecatedNextContext) {\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n      } else {\n        context = observerOrNext;\n      }\n      next = next === null || next === void 0 ? void 0 : next.bind(context);\n      error = error === null || error === void 0 ? void 0 : error.bind(context);\n      complete = complete === null || complete === void 0 ? void 0 : complete.bind(context);\n    }\n    this.destination = {\n      next: next ? wrapForErrorHandling(next, this) : noop,\n      error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler, this),\n      complete: complete ? wrapForErrorHandling(complete, this) : noop\n    };\n  }\n}\nfunction wrapForErrorHandling(handler, instance) {\n  return (...args) => {\n    try {\n      handler(...args);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(err);\n      } else {\n        reportUnhandledError(err);\n      }\n    }\n  };\n}\nfunction defaultErrorHandler(err) {\n  throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n  const {\n    onStoppedNotification\n  } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\nexport const EMPTY_OBSERVER = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop\n};","map":{"version":3,"names":["isFunction","isSubscription","Subscription","config","reportUnhandledError","noop","nextNotification","errorNotification","COMPLETE_NOTIFICATION","timeoutProvider","captureError","Subscriber","constructor","destination","isStopped","add","EMPTY_OBSERVER","create","next","error","complete","SafeSubscriber","value","handleStoppedNotification","_next","err","_error","_complete","unsubscribe","closed","observerOrNext","context","useDeprecatedNextContext","Object","bind","wrapForErrorHandling","defaultErrorHandler","handler","instance","args","useDeprecatedSynchronousErrorHandling","notification","subscriber","onStoppedNotification","setTimeout"],"sources":["/Users/hinddeeppurohit/Documents/MitacsAngular/node_modules/rxjs/dist/esm/internal/Subscriber.js"],"sourcesContent":["import { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nexport class Subscriber extends Subscription {\n    constructor(destination) {\n        super();\n        this.isStopped = false;\n        if (destination) {\n            this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(this);\n            }\n        }\n        else {\n            this.destination = EMPTY_OBSERVER;\n        }\n    }\n    static create(next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    }\n    next(value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    }\n    error(err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    }\n    complete() {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            this.isStopped = true;\n            super.unsubscribe();\n            this.destination = null;\n        }\n    }\n    _next(value) {\n        this.destination.next(value);\n    }\n    _error(err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n    _complete() {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n}\nexport class SafeSubscriber extends Subscriber {\n    constructor(observerOrNext, error, complete) {\n        super();\n        let next;\n        if (isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            ({ next, error, complete } = observerOrNext);\n            let context;\n            if (this && config.useDeprecatedNextContext) {\n                context = Object.create(observerOrNext);\n                context.unsubscribe = () => this.unsubscribe();\n            }\n            else {\n                context = observerOrNext;\n            }\n            next = next === null || next === void 0 ? void 0 : next.bind(context);\n            error = error === null || error === void 0 ? void 0 : error.bind(context);\n            complete = complete === null || complete === void 0 ? void 0 : complete.bind(context);\n        }\n        this.destination = {\n            next: next ? wrapForErrorHandling(next, this) : noop,\n            error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler, this),\n            complete: complete ? wrapForErrorHandling(complete, this) : noop,\n        };\n    }\n}\nfunction wrapForErrorHandling(handler, instance) {\n    return (...args) => {\n        try {\n            handler(...args);\n        }\n        catch (err) {\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                captureError(err);\n            }\n            else {\n                reportUnhandledError(err);\n            }\n        }\n    };\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    const { onStoppedNotification } = config;\n    onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\nexport const EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}